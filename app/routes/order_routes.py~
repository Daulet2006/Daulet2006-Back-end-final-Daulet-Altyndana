# app/routes/order_routes.py
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from ..models import Order, Product, Pet, User, Role, order_product, order_pet
from .. import db
from datetime import datetime
from ..utils import role_required

bp = Blueprint('orders', __name__, url_prefix='/orders')


# Helper functions
def format_order(order):
    """
    Форматирует объект заказа для ответа в JSON.
    """
    # Получение продуктов в заказе
    products_data = []
    product_associations = db.session.query(order_product).filter_by(order_id=order.id).all()
    for assoc in product_associations:
        product = Product.query.get(assoc.product_id)
        if product:
            products_data.append({
                'id': product.id,
                'name': product.name,
                'quantity': assoc.quantity,
                'price': product.price
            })

    # Получение питомцев в заказе
    pets_data = [{
        'id': p.id,
        'name': p.name,
        'species': p.species,
        'price': p.price
    } for p in order.pets]

    return {
        'id': order.id,
        'client_id': order.client_id,
        'order_date': order.order_date.isoformat(),
        'total_amount': order.total_amount,
        'status': order.status,
        'products': products_data,
        'pets': pets_data
    }


def check_authorization(order, current_user_id, current_user_role):
    """
    Проверяет права доступа к заказу с учетом ролей и владения товарами.
    """
    if current_user_role == Role.CLIENT:
        return order.client_id == current_user_id
    
    if current_user_role in [Role.ADMIN, Role.OWNER]:
        return True
    
    if current_user_role == Role.SELLER:
        order_products = db.session.query(order_product).filter_by(order_id=order.id).all()
        seller_products = Product.query.filter_by(seller_id=current_user_id).all()
        seller_product_ids = {p.id for p in seller_products}
        return any(assoc.product_id in seller_product_ids for assoc in order_products)
    return False


# Create Order (Client only)
@bp.route('', methods=['POST'])
@jwt_required()
@role_required(Role.CLIENT)
def create_order():
    current_user_identity = get_jwt_identity()
    client_id = current_user_identity['id']

    data = request.get_json()
    if not data or 'products' not in data or 'pets' not in data:
        return jsonify({'message': 'Invalid request format'}), 400

    product_ids_with_quantity = data.get('products', [])
    pet_ids = data.get('pets', [])

    if not isinstance(product_ids_with_quantity, list) or not isinstance(pet_ids, list):
        return jsonify({'message': 'Products and pets must be lists'}), 400

    if not product_ids_with_quantity and not pet_ids:
        return jsonify({'message': 'Order must contain at least one product or pet'}), 400

    total_amount = 0
    products_in_order = []
    pets_in_order = []

    try:
        # Process products in the order
        for index, item in enumerate(product_ids_with_quantity):
            if not isinstance(item, dict) or 'id' not in item or 'quantity' not in item:
                return jsonify({'message': f'Invalid product format at index {index}'}), 400
            
            product_id = item['id']
            quantity = item['quantity']
            
            try:
                product_id = int(product_id)
                quantity = int(quantity)
            except (ValueError, TypeError):
                return jsonify({'message': f'Invalid product data at index {index}'}), 400

            product = Product.query.get(product_id)
            if not product:
                return jsonify({'message': f'Product with ID {product_id} not found'}), 404
            if product.stock < quantity:
                return jsonify({
                    'message': f'Insufficient stock for product {product.name} (ID: {product_id}). Available: {product.stock}'
                }), 400

            products_in_order.append({'product': product, 'quantity': quantity})
            total_amount += product.price * quantity
            # Don't decrease stock yet, wait until the order is fully created

        # Process pets in the order
        for index, pet_id in enumerate(pet_ids):
            if not isinstance(pet_id, int):
                return jsonify({'message': f'Invalid pet ID at index {index}: {pet_id}'}), 400

            pet = Pet.query.get(pet_id)
            if not pet:
                return jsonify({'message': f'Pet with ID {pet_id} not found'}), 404

            # Check if pet is already linked to another order
            existing_order_link = db.session.query(order_pet).filter_by(pet_id=pet.id).first()
            if existing_order_link or pet.status != 'available':
                return jsonify({'message': f'Pet {pet.name} (ID: {pet_id}) недоступен для заказа. Статус: {pet.status}'}), 400

            pets_in_order.append(pet)
            total_amount += pet.price

        # Create the new order
        new_order = Order(
            client_id=client_id,
            order_date=datetime.utcnow(),
            total_amount=total_amount,
            status='Pending'
        )
        db.session.add(new_order)
        db.session.flush()  # To get order ID

        # Add products to the order
        for item in products_in_order:
            stmt = order_product.insert().values(
                order_id=new_order.id,
                product_id=item['product'].id,
                quantity=item['quantity']
            )
            db.session.execute(stmt)
            
            # Now decrease the stock after we're sure the order is being created
            item['product'].stock -= item['quantity']

        # Add pets to the order
        new_order.pets.extend(pets_in_order)

        db.session.commit()
        return jsonify({'message': 'Order created successfully', 'order_id': new_order.id}), 201

    except Exception as e:
        db.session.rollback()
        print(f"Error creating order: {e}")
        return jsonify({'message': 'Failed to create order', 'error': str(e)}), 500


# Get All Orders
@bp.route('', methods=['GET'])
@jwt_required()
def get_orders():
    current_user_identity = get_jwt_identity()
    current_user_id = current_user_identity['id']
    current_user_role = Role(current_user_identity['role'])

    try:
        query = Order.query
        if current_user_role == Role.CLIENT:
            query = query.filter_by(client_id=current_user_id)

        orders = query.order_by(Order.order_date.desc()).all()
        return jsonify([format_order(order) for order in orders]), 200
    except Exception as e:
        return jsonify({'message': 'Failed to retrieve orders', 'error': str(e)}), 500


# Get Single Order
@bp.route('/<int:order_id>', methods=['GET'])
@jwt_required()
def get_order(order_id):
    current_user_identity = get_jwt_identity()
    current_user_id = current_user_identity['id']
    current_user_role = Role(current_user_identity['role'])

    try:
        order = Order.query.get_or_404(order_id)
        if not check_authorization(order, current_user_id, current_user_role):
            return jsonify({'message': 'Permission denied'}), 403
        return jsonify(format_order(order)), 200
    except Exception as e:
        return jsonify({'message': 'Failed to retrieve order', 'error': str(e)}), 500


# Update Order Status (Admin/Owner only)
@bp.route('/<int:order_id>', methods=['PUT', 'PATCH'])
@jwt_required()
@role_required(Role.ADMIN, Role.OWNER, Role.SELLER)
def update_order(order_id):
    current_user_identity = get_jwt_identity()
    current_user_id = current_user_identity['id']
    current_user_role = Role(current_user_identity['role'])

    try:
        order = Order.query.get_or_404(order_id)
        
        if not check_authorization(order, current_user_id, current_user_role):
            return jsonify({'message': 'Permission denied'}), 403

        data = request.get_json()
        new_status = data.get('status')

        if not new_status:
            return jsonify({'message': 'Missing status field'}), 400

        # Validate status transition
        allowed_transitions = {
            'Pending': ['Processing', 'Cancelled'],
            'Processing': ['Shipped', 'Cancelled'],
            'Shipped': ['Completed'],
            'Cancelled': [],
            'Completed': []
        }

        if new_status not in allowed_transitions.get(order.status, []):
            return jsonify({'message': f'Invalid status transition from {order.status} to {new_status}'}), 400

        # Update pet statuses
        if new_status == 'Cancelled':
            for pet in order.pets:
                pet.status = 'available'
        elif new_status == 'Completed':
            for pet in order.pets:
                pet.status = 'sold'

        order.status = new_status
        db.session.commit()
        return jsonify({'message': 'Order updated successfully'}), 200

    except Exception as e:
        db.session.rollback()
        return jsonify({'message': 'Failed to update order', 'error': str(e)}), 500


# Delete Order (Admin/Owner only)
@bp.route('/<int:order_id>', methods=['DELETE'])
@jwt_required()
@role_required(Role.ADMIN, Role.OWNER)
def delete_order(order_id):
    try:
        order = Order.query.get_or_404(order_id)
        db.session.delete(order)
        db.session.commit()
        return jsonify({'message': 'Order deleted successfully'}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'message': 'Failed to delete order', 'error': str(e)}), 500

    # Add pets to the order
    for pet in pets_in_order:
        pet.status = 'reserved'
        new_order.pets.append(pet)

    db.session.commit()
    return jsonify({'message': 'Order created successfully', 'order_id': new_order.id}), 201
